{
  "metadata": {
    "version": "3.0",
    "description": "Generic, schema-agnostic rules for Elasticsearch query generation",
    "last_updated": "2025-09-24",
    "features": ["nested_query_support", "field_type_detection", "date_handling", "mobile_number_support"]
  },
  "SCHEMA_ANALYSIS_RULES": {
    "field_type_categorizer": {
      "rule": "analyze_schema_and_categorize_all_fields_by_type",
      "categories": {
        "keyword_fields": "fields_where_type_equals_keyword",
        "text_fields": "fields_where_type_equals_text", 
        "numeric_fields": "fields_where_type_in_[long,integer,float,double]",
        "date_fields": "fields_where_type_equals_date",
        "boolean_fields": "fields_where_type_equals_boolean",
        "nested_objects": "fields_where_type_equals_nested"
      },
      "instruction": "Extract all field paths from schema and group by type for query strategy selection"
    },
    "nested_path_extractor": {
      "rule": "identify_all_nested_object_paths_and_their_child_fields",
      "instruction": "For each nested type field, map all child field paths that require nested query wrapping",
      "example": "participants.mobileData.mobileNumber requires nested query with path 'participants'"
    },
    "analyzer_field_detector": {
      "rule": "identify_fields_with_custom_analyzers",
      "instruction": "Detect fields with edge_ngram, n_gram, or custom analyzers for specialized search strategies"
    }
  },
  "QUERY_TYPE_DETERMINATION_RULES": {
    "keyword_field_query_rule": {
      "rule": "for_any_field_where_type_is_keyword",
      "query_strategy": "use_term_or_terms_query",
      "exact_match": true,
      "case_sensitive": false,
      "instruction": "Keyword fields require exact value matching using term query",
      "multi_value_handling": "use_terms_query_for_multiple_values"
    },
    "text_field_query_rule": {
      "rule": "for_any_field_where_type_is_text",
      "query_strategy": "use_match_or_match_phrase_query",
      "fuzzy_matching": true,
      "instruction": "Text fields support fuzzy matching and phrase queries",
      "analyzer_consideration": "respect_field_analyzer_settings"
    },
    "numeric_field_query_rule": {
      "rule": "for_any_field_where_type_is_numeric",
      "query_strategy": "use_term_for_exact_or_range_for_comparisons",
      "supported_operators": ["gte", "lte", "gt", "lt", "eq"],
      "instruction": "Numeric fields support both exact matches and range queries"
    },
    "date_field_query_rule": {
      "rule": "for_any_field_where_type_is_date",
      "query_strategy": "use_range_query_with_proper_format",
      "format_handling": "convert_user_dates_to_appropriate_format",
      "instruction": "Date fields require range queries with proper epoch millisecond conversion"
    },
    "boolean_field_query_rule": {
      "rule": "for_any_field_where_type_is_boolean",
      "query_strategy": "use_term_query",
      "accepted_values": ["true", "false"],
      "instruction": "Boolean fields only accept true/false values using term query"
    }
  },
  "NESTED_QUERY_RULES": {
    "nested_field_detection_rule": {
      "rule": "if_queried_field_path_starts_with_any_nested_parent_path",
      "detection_logic": "check_if_field_is_child_of_nested_type_field",
      "action": "wrap_query_in_nested_wrapper",
      "instruction": "Any field under nested type must be wrapped in nested query with correct path"
    },
    "nested_query_wrapper_rule": {
      "rule": "wrap_child_field_queries_in_nested_query_structure",
      "structure": {
        "nested": {
          "path": "detected_nested_parent_path",
          "query": "child_field_query"
        }
      },
      "instruction": "Use the parent nested field path, not the full child field path"
    },
    "nested_combination_rule": {
      "rule": "when_multiple_fields_under_same_nested_path",
      "strategy": "combine_child_queries_within_single_nested_wrapper",
      "instruction": "Don't create multiple nested queries for the same path, combine them"
    }
  },
  "QUERY_COMBINATION_RULES": {
    "multiple_field_combination_rule": {
      "rule": "when_user_specifies_multiple_conditions",
      "default_logic": "use_bool_query_with_must_clauses",
      "structure": {
        "query": {
          "bool": {
            "must": ["array_of_individual_field_queries"]
          }
        }
      },
      "instruction": "Combine all conditions using AND logic unless user specifies OR"
    },
    "same_intent_multiple_fields_rule": {
      "rule": "when_user_intent_could_match_multiple_similar_fields",
      "strategy": "use_should_query_to_search_across_similar_fields",
      "instruction": "For ambiguous terms, search across related fields using should clauses"
    }
  },
  "FIELD_DISCOVERY_RULES": {
    "semantic_field_matching_rule": {
      "rule": "map_user_terms_to_schema_fields_by_semantic_similarity",
      "examples": {
        "mobile_terms": ["mobile", "phone", "number", "contact"],
        "status_terms": ["status", "state", "condition"],
        "amount_terms": ["amount", "value", "price", "cost"],
        "date_terms": ["date", "time", "when", "created", "updated"]
      },
      "instruction": "Use semantic matching to find the most appropriate field for user intent"
    },
    "field_priority_ranking_rule": {
      "rule": "when_multiple_fields_match_user_intent",
      "priority_factors": ["field_name_similarity", "field_type_appropriateness", "nested_vs_direct"],
      "instruction": "Rank potential fields and choose the most appropriate one"
    }
  },
  "VALUE_PROCESSING_RULES": {
    "exact_value_preservation_rule": {
      "rule": "preserve_user_provided_values_exactly_as_given",
      "instruction": "Don't modify user values unless format conversion is required",
      "exceptions": ["date_format_conversion", "boolean_normalization"]
    },
    "numeric_value_handling_rule": {
      "rule": "detect_and_properly_handle_numeric_values",
      "type_conversion": "convert_string_numbers_to_appropriate_numeric_types",
      "instruction": "Ensure numeric values are not quoted in the final query"
    }
  },
  "VALIDATION_RULES": {
    "field_existence_validation_rule": {
      "rule": "verify_all_referenced_fields_exist_in_schema",
      "fallback_strategy": "suggest_similar_field_names_or_use_generic_search",
      "instruction": "Validate field names against schema before building query"
    },
    "query_type_compatibility_rule": {
      "rule": "ensure_query_type_matches_field_type",
      "validation_matrix": {
        "keyword_fields": ["term", "terms", "wildcard"],
        "text_fields": ["match", "match_phrase", "wildcard"],
        "numeric_fields": ["term", "range"],
        "date_fields": ["range"],
        "boolean_fields": ["term"]
      },
      "instruction": "Prevent incompatible query types that would cause ES errors"
    }
  },
  "OPTIMIZATION_RULES": {
    "performance_optimization_rule": {
      "rule": "optimize_query_structure_for_performance",
      "strategies": [
        "use_filter_context_for_exact_matches",
        "avoid_wildcard_on_large_text_fields", 
        "prefer_term_over_match_for_keyword_fields",
        "limit_nested_query_complexity"
      ],
      "instruction": "Build queries that perform well on large datasets"
    }
  },
  "QUERY_STRUCTURE_RULES": {
    "bool_query_requirement_rule": {
      "rule": "always_use_bool_query_as_root_structure",
      "structure": {
        "query": {
          "bool": {
            "must": ["required_conditions"],
            "should": ["optional_conditions"],
            "filter": ["non_scoring_filters"]
          }
        }
      },
      "instruction": "Wrap all queries in bool structure for consistency and extensibility"
    },
    "query_defaults_rule": {
      "rule": "apply_sensible_defaults_for_common_scenarios",
      "defaults": {
        "size": 10,
        "track_total_hits": true,
        "timeout": "30s"
      },
      "instruction": "Include reasonable defaults unless user specifies otherwise"
    }
  },
  "DATE_HANDLING_BUSINESS_RULES": {
    "format_requirements": {
      "llm_query_format": "dd/MM/yyyy",
      "execution_format": "epoch_milliseconds",
      "mcp_tool_format": "yyyy-MM-dd"
    },
    "business_logic": {
      "no_date_specified": "gte = start_of_current_month (00:00:00), lte = current_datetime (now)",
      "single_date_specified": "gte = provided_date (00:00:00), lte = current_datetime (now)",
      "two_dates_specified": "gte = smaller_date (00:00:00), lte = larger_date (23:59:59)"
    },
    "detailed_rules": {
      "rule_1_no_dates": {
        "condition": "user_has_not_specified_any_dates",
        "gte": "1st day of current month at 00:00:00 hours",
        "lte": "current date and time (now)",
        "example": "If today is 25/09/2025 14:30, then gte=01/09/2025 00:00:00, lte=25/09/2025 14:30"
      },
      "rule_2_single_date": {
        "condition": "user_specified_only_one_date",
        "gte": "specified date at 00:00:00 hours", 
        "lte": "current date and time (now)",
        "example": "User says '10/09/2025', then gte=10/09/2025 00:00:00, lte=current_datetime"
      },
      "rule_3_two_dates": {
        "condition": "user_specified_two_dates",
        "gte": "smaller date at 00:00:00 hours",
        "lte": "larger date at 23:59:59 hours",
        "example": "User says '5/09/2025 to 15/09/2025', then gte=05/09/2025 00:00:00, lte=15/09/2025 23:59:59"
      }
    },
    "timezone": "Asia/Kolkata",
    "instruction": "CRITICAL: Always generate queries with dd/MM/yyyy format in the query JSON. The DateQueryProcessor will extract these dates and convert them to epoch milliseconds with proper timezone handling."
  },
  "MOBILE_NUMBER_HANDLING": {
    "detection_rule": "identify_mobile_number_requests_in_user_prompt",
    "field_discovery": "search_schema_for_mobile_related_nested_fields",
    "query_strategy": "use_nested_query_with_appropriate_path",
    "instruction": "Mobile numbers are typically in nested participant structures, ensure proper nested query"
  }
}